package dev.ase.teamproject.model;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

/**
 * This class defines the Transaction model used in the application.
 *  Each transcation represents a financial event linked to a specific user.
 *  A positive amount denotes an expense while a negative amount represents
 *  income or a refund. The class supports both date-only (for summaries) and
 *  timestamped (for precise ordering).
 */
public class Transaction implements Comparable<Transaction> {
  private UUID transactionId;
  private UUID userId;
  private String description;
  private double amount;
  private String category;
  private LocalDateTime timestamp;
  private LocalDate date;

  public Transaction() {
  }

  /**
   * Constructs a new {@code Transaction} with data. {@code transactionId},
   * {@code timestamp}, and {@code date} are  regenerated by the database.
   *
   * @param userId The unique identifier of the user who made the transaction.
   * @param amount The amount of the transaction (+ for expense, - for income).
   * @param category The category of the transaction.
   * @param description A brief description of the transaction.
   */
  public Transaction(final UUID userId, final double amount,
                     final String category, final String description) {
    this.userId = userId;
    this.amount = amount;
    this.category = category;
    setDescription(description);
  }

  public UUID getTransactionId() {
    return transactionId;
  }

  public void setTransactionId(final UUID userId) {
    this.transactionId = userId;
  }

  public UUID getUserId() {
    return userId;
  }

  public void setUserId(final UUID userId) {
    this.userId = userId;
  }

  public String getDescription() {
    return description;
  }

  /**
   * Sets the description of the transaction. If the provided description
   * is {@code null}, it defaults to an empty string. Leading and trailing
   * whitespace is automatically trimmed.
   *
   * @param description A brief description of the transaction.
   */
  public void setDescription(final String description) {
    this.description = (description == null) ? "" : description.trim();
  }

  public double getAmount() {
    return amount;
  }

  public void setAmount(final double amount) {
    this.amount = amount;
  }

  public LocalDateTime getTimestamp() {
    return timestamp;
  }

  /**
   * Sets the exact timestamp for the transaction. If a timestamp is provided,
   * the corresponding date field is updated to match.
   *
   * @param timestamp The {@code LocalDateTime} value representing
   *                  when the transaction occurred.
   */
  public void setTimestamp(final LocalDateTime timestamp) {
    this.timestamp = timestamp;
    if (timestamp != null) {
      this.date = timestamp.toLocalDate();
    }
  }

  public LocalDate getDate() {
    return date;
  }

  /**
   * Sets the calendar date for the transaction. If a date is provided
   * but no timestamp exists, the timestamp is automatically set
   * to the start of that day for consistency.
   *
   * @param date The {@code LocalDate} value representing the transaction date.
   */
  public void setDate(final LocalDate date) {
    this.date = date;

    // If timestamp is still null, set it to start of the effective day
    if (date != null && this.timestamp == null) {
      this.timestamp = date.atStartOfDay();
    }
  }

  public String getCategory() {
    return category;
  }

  public void setCategory(final String category) {
    this.category = category;
  }

  /**
   * Returns the preferred ordering instant for this transaction.
   * If a timestamp exists, it is returned.
   * If only a date exists, it returns the start-of-day of that date.
   * If neither exists, {@code null} is returned.
   *
   * @return the preferred {@code LocalDateTime} instant for ordering,
   *     or {@code null} if unavailable.
   */
  public LocalDateTime effectiveInstant() {
    if (timestamp != null) {
      return timestamp;
    }
    if (date != null) {
      return date.atStartOfDay();
    }
    return null;
  }

  /**
   * Compares this transaction to another based on their effective instants.
   * Transactions are ordered primarily by their timestamp (or date if timestamp
   * is unavailable). When timestamps are equal or both {@code null}, transactions
   * are ordered by their unique identifier. Transactions with {@code null} instants
   * are ordered before those with valid instants.
   *
   * @param other The transaction to compare against.
   * @return a negative integer, zero, or a positive integer as this transaction
   *         is less than, equal to, or greater than the specified transaction.
   */
  @Override
  public int compareTo(final Transaction other) {
    if (other == null) {
      return 1;
    }
    final LocalDateTime thisDateTime = this.effectiveInstant();
    final LocalDateTime otherDateTime = other.effectiveInstant();

    if (thisDateTime == null && otherDateTime == null) {
      final UUID thisUuid = this.transactionId;
      final UUID otherUuid = other.transactionId;
      if (thisUuid == null && otherUuid == null) {
        return 0;
      }
      if (thisUuid == null) {
        return -1;
      }
      if (otherUuid == null) {
        return 1;
      }
      return thisUuid.compareTo(otherUuid);
    }

    if (thisDateTime == null) {
      return -1;
    }
    if (otherDateTime == null) {
      return 1;
    }

    final int cmp = thisDateTime.compareTo(otherDateTime);
    if (cmp != 0) {
      return cmp;
    }

    final UUID thisUuid = this.transactionId;
    final UUID otherUuid = other.transactionId;
    if (thisUuid == null && otherUuid == null) {
      return 0;
    }
    if (thisUuid == null) {
      return -1;
    }
    if (otherUuid == null) {
      return 1;
    }
    return thisUuid.compareTo(otherUuid);
  }

  /**
   * Indicates whether some other object is "equal to" this one.
   * Two transactions are considered equal if they have the same transaction ID.
   *
   * @param other The reference object with which to compare.
   * @return {@code true} if this transaction has the same ID as the other object;
   *         {@code false} otherwise.
   */
  @Override
  public boolean equals(final Object other) {
    if (this == other) {
      return true;
    }
    if (!(other instanceof Transaction)) {
      return false;
    }
    final Transaction transaction = (Transaction) other;
    return Objects.equals(transactionId, transaction.transactionId);
  }

  /**
   * Returns a hash code value for this transaction based on its unique identifier.
   *
   * @return a hash code value for this transaction.
   */
  @Override
  public int hashCode() {
    return Objects.hash(transactionId);
  }

  /**
   * Returns a string representation of the transaction, including its ID,
   * description, amount, timestamp, date, and category.
   *
   * @return a string representation of this transaction.
   */
  @Override
  public String toString() {
    return "Transaction{"
        + "id=" + transactionId
        + ", description='" + description + '\''
        + ", amount=" + amount
        + ", timestamp=" + timestamp
        + ", date=" + date
        + ", category='" + category + '\''
        + '}';
  }
}
