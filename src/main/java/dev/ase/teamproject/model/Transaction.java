package dev.ase.teamproject.model;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

/**
 * This class defines the Transaction model used in the application.
 *  Each transcation represents a financial event linked to a specific user.
 *  A positive amount denotes an expense while a negative amount represents
 *  income or a refund. The class supports both date-only (for summaries) and
 *  timestamped (for precise ordering).
 */
@SuppressWarnings({
    "PMD.DataClass", // Class primarily holds data
    "PMD.OnlyOneReturn", // Multiple return statements for clarity
    "PMD.CommentSize", // Comments enhance understanding
    "PMD.CyclomaticComplexity", // Complexity justified for compareTo
    "PMD.CognitiveComplexity", // Complexity justified for compareTo
    "PMD.ConstructorCallsOverridableMethod" // Safe usage in constructor
})
public class Transaction implements Comparable<Transaction> {
  /** The unique identifier for the transaction. */
  private UUID transactionId;

  /** The unique identifier of the user who made the transaction. */
  private UUID userId;

  /** A brief description of the transaction. */
  private String description; 

  /** The amount of the transaction (positive for expense, negative for income). */
  private double amount;

  /** The category of the transaction. */
  private String category;

  /** The exact timestamp when the transaction occurred. */
  private LocalDateTime timestamp;

  /** The calendar date of the transaction (without time). */
  private LocalDate date;

  /** Default constructor for Transaction. */
  public Transaction() {
    // no-op
  }

  /**
   * Constructs a new {@code Transaction} with data. {@code transactionId}, 
   * {@code timestamp}, and {@code date} are  regenerated by the database.
   *
   * @param userId The unique identifier of the user who made the transaction.
   * @param amount The amount of the transaction (+ for expense, - for income).
   * @param category The category of the transaction.
   * @param description A brief description of the transaction.
   */
  public Transaction(final UUID userId, final double amount, final String category, final String description) {
    this.userId = userId;
    this.amount = amount;
    this.category = category;
    setDescription(description);
  }

  /** Getter for the transaction ID. */
  public UUID getTransactionId() { 
    return transactionId; 
  }

  /** Setter for the transaction ID. */
  public void setTransactionId(final UUID userId) { 
    this.transactionId = userId; 
  }

  /** Getter for the user ID associated with this transaction. */
  public UUID getUserId() { 
    return userId; 
  }

  /** Setter for the user ID associated with this transaction. */
  public void setUserId(final UUID userId) {
    this.userId = userId; 
  }

  /** Getter for the description of the transaction. */
  public String getDescription() {
    return description; 
  }

  /** Setter for the description of the transaction. */
  public void setDescription(final String description) {
    this.description = (description == null) ? "" : description.trim();
  }

  /** Getter for the amount of the transaction. */
  public double getAmount() { 
    return amount; 
  }

  /** Setter for the amount of the transaction. */
  public void setAmount(final double amount) { 
    this.amount = amount; 
  }

  /** Getter for the exact timestamp of the transaction. */
  public LocalDateTime getTimestamp() { 
    return timestamp; 
  }

  /**
   * Sets the exact timestamp for the transaction. If a timestamp is provided, 
   * the corresponding date field is updated to match.
   *
   * @param timestamp The {@code LocalDateTime} value representing 
   *                  when the transaction occurred.
   */
  public void setTimestamp(final LocalDateTime timestamp) {
    // If timestamp is null, use current time
    final LocalDateTime effectiveTime =
        (timestamp == null) ? LocalDateTime.now() : timestamp;

    this.timestamp = effectiveTime;
    this.date = effectiveTime.toLocalDate();
  }

  /** Getter for the calendar date of the transaction. */
  public LocalDate getDate() { 
    return date; 
  }

  /**
   * Sets the calendar date for the transaction. If a date is provided
   * but no timestamp exists, the timestamp is automatically set
   * to the start of that day for consistency.
   *
   * @param date The {@code LocalDate} value representing the transaction date.
   */
  public void setDate(final LocalDate date) {
    // If date is null, use today's date
    final LocalDate effectiveDate =
        (date == null) ? LocalDate.now() : date;

    this.date = effectiveDate;

    // If timestamp is still null, set it to start of the effective day
    if (this.timestamp == null) {
      this.timestamp = effectiveDate.atStartOfDay();
    }
  }

  /** Getter for the category of the transaction. */
  public String getCategory() { 
    return category; 
  }

  /** Setter for the category of the transaction. */
  public void setCategory(final String category) { 
    this.category = category; 
  }

  /**
   * Returns the preferred ordering instant for this transaction.
   * If a timestamp exists, it is returned.
   * If only a date exists, it returns the start-of-day of that date.
   * If neither exists, {@code null} is returned.
   *
   * @return the preferred {@code LocalDateTime} instant for ordering,
   *     or {@code null} if unavailable.
   */
  public LocalDateTime effectiveInstant() {
    if (timestamp != null) {
      return timestamp;
    }
    if (date != null) {
      return date.atStartOfDay();
    }
    return null;
  }

  /** Compares this transaction to another based on their effective instants. */
  @Override
  public int compareTo(final Transaction other) {
    if (other == null) {
      return 1;
    }
    final LocalDateTime thisDateTime = this.effectiveInstant();
    final LocalDateTime otherDateTime = other.effectiveInstant();
    
    if (thisDateTime == null && otherDateTime == null) {
      final UUID thisUuid = this.transactionId;
      final UUID otherUuid = other.transactionId;
      if (thisUuid == null && otherUuid == null) {
        return 0;
      }
      if (thisUuid == null) {
        return -1;
      }
      if (otherUuid == null) {
        return 1;
      }
      return thisUuid.compareTo(otherUuid);
    }
    
    if (thisDateTime == null) {
      return -1;
    }
    if (otherDateTime == null) {
      return 1;
    }

    final int cmp = thisDateTime.compareTo(otherDateTime);
    if (cmp != 0) {
      return cmp;
    }
    
    final UUID thisUuid = this.transactionId;
    final UUID otherUuid = other.transactionId;
    if (thisUuid == null && otherUuid == null) {
      return 0;
    }
    if (thisUuid == null) {
      return -1;
    }
    if (otherUuid == null) {
      return 1;
    }
    return thisUuid.compareTo(otherUuid);
  }

  /** Compares this transaction to another based on their effective instants. */
  @Override
  public boolean equals(final Object other) {
    if (this == other) {
      return true;
    }
    if (!(other instanceof Transaction)) {
      return false;
    }
    final Transaction transaction = (Transaction) other;
    return Objects.equals(transactionId, transaction.transactionId);
  }

  /** Returns a hash code for this transaction based on its ID. */
  @Override
  public int hashCode() { 
    return Objects.hash(transactionId); 
  }

  /** Returns a string representation of the transaction. */
  @Override
  public String toString() {
    return "Transaction{"
            + "id=" + transactionId
            + ", description='" + description + '\''
            + ", amount=" + amount
            + ", timestamp=" + timestamp
            + ", date=" + date
            + ", category='" + category + '\''
            + '}';
  }
}
