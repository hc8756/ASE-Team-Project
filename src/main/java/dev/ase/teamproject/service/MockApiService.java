package dev.ase.teamproject.service;

import dev.ase.teamproject.model.Transaction;
import dev.ase.teamproject.model.User;
import java.time.LocalDate;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Service;

/**
 * This class defines the Mock API Service responsible for managing
 * interactions between the application and the PostgreSQL database.
 * It provides CRUD operations for users and transactions, as well as
 * analytics and budgeting functionalities.
 * All methods in this class use the Spring JdbcTemplate for data access.
 */
@Service
public class MockApiService {
  private final JdbcTemplate jdbcTemplate;

  private final RowMapper<User> userRowMapper = (rs, rowNum) -> {
    final User user = new User();
    user.setUserId((UUID) rs.getObject("user_id"));
    user.setUsername(rs.getString("username"));
    user.setEmail(rs.getString("email"));
    user.setBudget(rs.getDouble("budget"));
    return user;
  };

  private final RowMapper<Transaction> txRowMapper = (rs, rowNum) -> {
    final Transaction transaction = new Transaction();
    try {
      transaction.setTransactionId((UUID) rs.getObject("transaction_id"));
      transaction.setUserId((UUID) rs.getObject("user_id"));
      transaction.setDescription(rs.getString("description"));
      transaction.setAmount(rs.getDouble(AMOUNT));
      transaction.setCategory(rs.getString("category"));

      // Handle potential null values for timestamps
      if (rs.getTimestamp("created_time") != null) {
        transaction.setTimestamp(rs.getTimestamp("created_time").toLocalDateTime());
      }

      if (rs.getDate("created_date") != null) {
        transaction.setDate(rs.getDate("created_date").toLocalDate());
      }

      return transaction;
    } catch (Exception e) {
      throw new IllegalStateException("Error mapping transaction row: " + e.getMessage(), e);
    }
  };

  private static final String USER_NOT_FOUND = "User not found";
  private static final String AMOUNT = "amount";

  /**
   * Constructs a new {@code MockApiService} with the specified {@code JdbcTemplate}.
   *
   * @param jdbcTemplate A {@code JdbcTemplate} used to communicate with database.
   */
  public MockApiService(final JdbcTemplate jdbcTemplate) {
    this.jdbcTemplate = jdbcTemplate;
  }

  /**
   * Retrieves all users from the database.
   *
   * @return A {@code List} of all {@code User} records.
   */
  public List<User> viewAllUsers() {
    final String sql = "SELECT * FROM users";
    return jdbcTemplate.query(sql, userRowMapper);
  }

  /**
   * Retrieves a specific user by their unique identifier.
   *
   * @param userId The {@code UUID} of the user to retrieve.
   * @return An {@code Optional} containing the {@code User} if found,
   *         or empty if not found.
   */
  public Optional<User> getUser(final UUID userId) {
    final String sql = "SELECT * FROM users WHERE user_id = ?";
    try {
      final User user = jdbcTemplate.queryForObject(sql, userRowMapper, userId);
      return Optional.ofNullable(user);
    } catch (Exception e) {
      return Optional.empty();
    }
  }

  /**
   * Adds a new user to the database. If the user already has a {@code userId},
   * it is used directly; otherwise, a new {@code UUID} is generated by the database.
   *
   * @param user The {@code User} object containing username, email, and budget.
   * @return The created {@code User} object with its assigned {@code UUID}.
   */
  public User addUser(final User user) {
    if (user.getUserId() != null) {
      final String sql = "INSERT INTO users (user_id, username, email, budget) VALUES (?, ?, ?, ?)";
      jdbcTemplate.update(sql,
          user.getUserId(),  // Use the provided UUID
          user.getUsername(),
          user.getEmail(),
          user.getBudget());
      return user;  // Return as-is
    } else {
      final String sql =
          "INSERT INTO users (username, email, budget) VALUES (?, ?, ?) RETURNING user_id";
      final UUID generatedUserId = jdbcTemplate.queryForObject(sql, UUID.class,
          user.getUsername(), user.getEmail(), user.getBudget());
      user.setUserId(generatedUserId);
      return user;
    }
  }

  /**
   * Deletes a user by their unique identifier.
   *
   * @param userId The {@code UUID} of the user to delete.
   * @return {@code true} if a record was deleted; {@code false} otherwise.
   */
  public boolean deleteUser(final UUID userId) {
    final String sql = "DELETE FROM users WHERE user_id = ?";
    final int rowsAffected = jdbcTemplate.update(sql, userId);
    return rowsAffected > 0;
  }

  /**
   * Retrieves all transactions sorted by most recent creation time.
   *
   * @return A {@code List} of {@code Transaction} objects
   *         sorted by {@code created_time}.
   */
  public List<Transaction> viewAllTransactions() {
    final String sql = "SELECT * FROM transactions ORDER BY created_time DESC";
    return jdbcTemplate.query(sql, txRowMapper);
  }

  /**
   * Retrieves a specific transaction by its unique identifier.
   *
   * @param transactionId The {@code UUID} of the transaction to retrieve.
   * @return An {@code Optional} containing the {@code Transaction} if found,
   *         or empty if not.
   */
  public Optional<Transaction> getTransaction(final UUID transactionId) {
    final String sql = "SELECT * FROM transactions WHERE transaction_id = ?";
    try {
      final Transaction transaction = jdbcTemplate
          .queryForObject(sql, txRowMapper, transactionId);
      return Optional.ofNullable(transaction);
    } catch (Exception e) {
      return Optional.empty();
    }
  }

  /**
   * Creates a new transaction record in the database. Validates that all required
   * fields are present and valid before insertion. The database automatically
   * generates the transaction ID, timestamp, and date.
   *
   * @param transaction The {@code Transaction} to insert.
   * @return The created {@code Transaction} with database-generated fields populated.
   * @throws IllegalArgumentException if required fields are missing, invalid, or
   *         if the user ID does not exist.
   * @throws IllegalStateException if the insert operation fails.
   */
  public Transaction addTransaction(final Transaction transaction) {
    // Validate required fields before database operation
    if (transaction.getUserId() == null) {
      throw new IllegalArgumentException("User ID is required");
    }
    final String description = transaction.getDescription();
    if (description == null || description.isBlank()) {
      throw new IllegalArgumentException("Description is required");
    }
    if (transaction.getAmount() <= 0) {
      throw new IllegalArgumentException("Amount must be greater than 0");
    }
    final String category = transaction.getCategory();
    if (category == null || category.isBlank()) {
      throw new IllegalArgumentException("Category is required");
    }

    try {
      final String sql = "INSERT INTO transactions (user_id, description, amount, category) "
          + "VALUES (?, ?, ?, ?::transaction_category) "
          + "RETURNING transaction_id, created_time, created_date";
      final Transaction savedTransaction = jdbcTemplate.queryForObject(sql, (rs, rowNum) -> {
        transaction.setTransactionId(rs.getObject("transaction_id", UUID.class));
        transaction.setTimestamp(rs.getTimestamp("created_time").toLocalDateTime());
        transaction.setDate(rs.getDate("created_date").toLocalDate());
        return transaction;
      },
          transaction.getUserId(),
          transaction.getDescription(),
          transaction.getAmount(),
          transaction.getCategory());
      return savedTransaction != null ? savedTransaction : transaction;
    } catch (Exception e) {
      final String message = e.getMessage();
      if (message != null && message.contains("foreign key constraint")) {
        throw new IllegalArgumentException("Invalid user ID: user does not exist", e);
      } else if (message != null && (message.contains("transaction_category")
          || message.contains("enum"))) {
        throw new IllegalArgumentException("Invalid category. Valid categories are: FOOD,"
            + "TRANSPORTATION, ENTERTAINMENT, UTILITIES, SHOPPING,"
            + "HEALTHCARE, TRAVEL, EDUCATION, OTHER", e);
      } else if (message != null && (message.contains("numeric") || message.contains(AMOUNT))) {
        throw new IllegalArgumentException("Invalid amount format: must be a valid number", e);
      } else {
        throw new IllegalStateException("Failed to create transaction: " + message, e);
      }
    }
  }

  /**
   * Retrieves all transactions associated with a specific user, ordered by
   * most recent first.
   *
   * @param userId The {@code UUID} of the user.
   * @return A {@code List} of the user's {@code Transaction} records.
   * @throws IllegalStateException if the query fails.
   */
  public List<Transaction> getTransactionsByUser(final UUID userId) {
    try {
      final String sql = "SELECT * FROM transactions WHERE user_id = ? ORDER BY created_time DESC";
      return jdbcTemplate.query(sql, txRowMapper, userId);
    } catch (Exception e) {
      throw new IllegalStateException("Failed to get transactions: " + e.getMessage(), e);
    }
  }

  /**
   * Updates an existing transaction record with new values. Validates all provided
   * fields before applying changes. Only the fields present in the updates map
   * will be modified.
   *
   * @param transactionId The {@code UUID} of the transaction to update.
   * @param updates A {@code Map} containing the fields to modify and their new values.
   *                Valid keys are "description", "amount", and "category".
   * @return An {@code Optional} of the updated {@code Transaction}.
   * @throws IllegalArgumentException if the transaction is not found, if no valid
   *         fields are provided, or if any field value is invalid.
   * @throws IllegalStateException if the update operation fails.
   */
  public Optional<Transaction> updateTransaction(
      final UUID transactionId, final Map<String, Object> updates) {
    final Optional<Transaction> existing = getTransaction(transactionId);
    if (!existing.isPresent()) {
      throw new IllegalArgumentException("Transaction not found with ID: " + transactionId);
    }

    final Transaction transaction = existing.get();

    // Validate and apply updates
    if (updates.containsKey("description")) {
      final Object description = updates.get("description");
      if (description instanceof String) {
        final String desc = (String) description;
        if (desc.isBlank()) {
          throw new IllegalArgumentException("Description cannot be empty");
        }
        transaction.setDescription(desc);
      } else {
        throw new IllegalArgumentException("Description must be a string");
      }
    }

    if (updates.containsKey(AMOUNT)) {
      final Object amount = updates.get(AMOUNT);
      final double newAmount;
      if (amount instanceof Number) {
        newAmount = ((Number) amount).doubleValue();
      } else if (amount instanceof String) {
        try {
          newAmount = Double.parseDouble((String) amount);
        } catch (NumberFormatException e) {
          throw new IllegalArgumentException("Amount must be a valid number", e);
        }
      } else {
        throw new IllegalArgumentException("Amount must be a number");
      }

      if (newAmount <= 0) {
        throw new IllegalArgumentException("Amount must be greater than 0");
      }
      transaction.setAmount(newAmount);
    }

    if (updates.containsKey("category")) {
      final Object category = updates.get("category");
      if (category instanceof String) {
        final String cat = (String) category;
        if (cat.isBlank()) {
          throw new IllegalArgumentException("Category cannot be empty");
        }
        // Validate category against known values
        final List<String> validCategories = Arrays.asList(
            "FOOD", "TRANSPORTATION", "ENTERTAINMENT", "UTILITIES",
            "SHOPPING", "HEALTHCARE", "TRAVEL", "EDUCATION", "OTHER"
        );
        if (!validCategories.contains(cat.toUpperCase(Locale.ROOT))) {
          throw new IllegalArgumentException("Invalid category: " + cat
              + ". Valid categories are: " + String.join(", ", validCategories));
        }
        transaction.setCategory(cat);
      } else {
        throw new IllegalArgumentException("Category must be a string");
      }
    }

    // Check if any valid updates were provided
    if (updates.isEmpty()) {
      throw new IllegalArgumentException("No valid fields provided for update");
    }

    final String sql = "UPDATE transactions SET description = ?, amount = ?, "
        + "category = ?::transaction_category WHERE transaction_id = ?";
    final int rowsAffected;
    try {
      rowsAffected = jdbcTemplate.update(sql,
          transaction.getDescription(),
          transaction.getAmount(),
          transaction.getCategory(),
          transactionId);
    } catch (DataAccessException e) {
      final String message = e.getMessage();
      if (message != null && (message.contains("transaction_category")
          || message.contains("enum"))) {
        throw new IllegalArgumentException("Invalid category. Valid categories are: "
            + "FOOD, TRANSPORTATION, ENTERTAINMENT, UTILITIES, SHOPPING, "
            + "HEALTHCARE, TRAVEL, EDUCATION, OTHER", e);
      }
      throw new IllegalStateException("Failed to update transaction: " + message, e);
    }

    if (rowsAffected > 0) {
      return getTransaction(transactionId);
    }
    throw new IllegalStateException("Failed to update transaction: no rows affected");
  }

  /**
   * Deletes a transaction record by its unique identifier.
   *
   * @param transactionId The {@code UUID} of the transaction to delete.
   * @return {@code true} if a record was deleted; {@code false} otherwise.
   */
  public boolean deleteTransaction(final UUID transactionId) {
    final String sql = "DELETE FROM transactions WHERE transaction_id = ?";
    final int rowsAffected = jdbcTemplate.update(sql, transactionId);
    return rowsAffected > 0;
  }

  /**
   * Generates a summary of a user's budget information, including total budget,
   * total spent, and remaining balance.
   *
   * @param userId The {@code UUID} of the user.
   * @return A formatted summary string with budget details, or "User not found"
   *         if the user does not exist.
   */
  public String getBudgetsTextBlock(final UUID userId) {
    final Optional<User> userOpt = getUser(userId);
    if (!userOpt.isPresent()) {
      return USER_NOT_FOUND;
    }
    final User user = userOpt.get();
    final List<Transaction> transactions = getTransactionsByUser(userId);
    final double totalSpent = transactions.stream()
        .filter(t -> t.getAmount() > 0)
        .mapToDouble(Transaction::getAmount)
        .sum();
    final double remaining = user.getBudget() - totalSpent;
    return String.format(
        "Budget Summary for %s:\n"
            + "Total Budget: $%.2f\n"
            + "Total Spent: $%.2f\n"
            + "Remaining: $%.2f",
        user.getUsername(), user.getBudget(), totalSpent, remaining
    );
  }

  /**
   * Generates warning messages for users who are near or over their budget.
   * A warning is issued if the user has exceeded their budget or has less than
   * 10% remaining.
   *
   * @param userId The {@code UUID} of the user.
   * @return A formatted string with warning messages, an empty string if no warnings
   *         apply, or "User not found" if the user does not exist.
   */
  public String getBudgetWarningsText(final UUID userId) {
    final Optional<User> userOpt = getUser(userId);
    if (!userOpt.isPresent()) {
      return USER_NOT_FOUND;
    }
    final User user = userOpt.get();
    final List<Transaction> transactions = getTransactionsByUser(userId);
    final double totalSpent = transactions.stream()
        .filter(t -> t.getAmount() > 0)
        .mapToDouble(Transaction::getAmount)
        .sum();
    final double remaining = user.getBudget() - totalSpent;
    final StringBuilder warnings = new StringBuilder(128);
    if (remaining < 0) {
      warnings.append("OVER BUDGET! You have exceeded your budget by $")
          .append(String.format("%.2f", -remaining)).append('\n');
    } else if (remaining < user.getBudget() * 0.1) {
      warnings.append("Budget warning: Only $").append(String.format("%.2f", remaining))
          .append(" remaining (less than 10%)\n");
    }
    return warnings.toString();
  }

  /**
   * Generates a monthly spending summary with category breakdown for the current month.
   * Includes total budget, amount spent, remaining balance, and spending broken down
   * by category in descending order.
   *
   * @param userId The {@code UUID} of the user.
   * @return A formatted multi-line string summarizing the user's monthly spending,
   *         or "User not found" if the user does not exist.
   */
  public String getMonthlySummary(final UUID userId) {
    final Optional<User> userOpt = getUser(userId);
    if (!userOpt.isPresent()) {
      return USER_NOT_FOUND;
    }
    final User user = userOpt.get();
    final List<Transaction> transactions = getTransactionsByUser(userId);
    final LocalDate now = LocalDate.now();
    final List<Transaction> monthTransactions = transactions.stream()
        .filter(t -> t.getDate() != null && t.getDate().getMonth()
            == now.getMonth() && t.getDate().getYear() == now.getYear())
        .collect(Collectors.toList());
    final double totalSpent = monthTransactions.stream()
        .filter(t -> t.getAmount() > 0)
        .mapToDouble(Transaction::getAmount)
        .sum();
    final double remaining = user.getBudget() - totalSpent;
    final StringBuilder summary = new StringBuilder(128);
    summary
        .append(String.format("Total Budget: $%.2f%n", user.getBudget()))
        .append(String.format("Total Spent: $%.2f%n", totalSpent))
        .append(String.format("Remaining: $%.2f%n%n", remaining))
        .append("Spending by Category:\n");
    final Map<String, Double> byCategory = monthTransactions.stream()
        .filter(t -> t.getAmount() > 0)
        .collect(Collectors.groupingBy(
            Transaction::getCategory,
            Collectors.summingDouble(Transaction::getAmount)
        ));
    byCategory.entrySet().stream()
        .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
        .forEach(entry -> {
          summary.append(String.format("- %s: $%.2f\n", entry.getKey(), entry.getValue()));
        });
    return summary.toString();
  }

  /**
   * Generates a comprehensive budget report containing analytics, totals, category
   * breakdown, and warnings. The report includes budget status, spending by category,
   * and whether the user is over budget or has warnings.
   *
   * @param userId The {@code UUID} of the user.
   * @return A {@code Map} with budget metrics and summaries, or a map containing
   *         an "error" key if the user is not found.
   */
  public Map<String, Object> getBudgetReport(final UUID userId) {
    final Optional<User> userOpt = getUser(userId);
    if (!userOpt.isPresent()) {
      return Map.of("error", USER_NOT_FOUND);
    }
    final User user = userOpt.get();
    final List<Transaction> transactions = getTransactionsByUser(userId);
    final double totalSpent = transactions.stream()
        .filter(t -> t.getAmount() > 0)
        .mapToDouble(Transaction::getAmount)
        .sum();
    final double remaining = user.getBudget() - totalSpent;
    final String warningsText = getBudgetWarningsText(userId);
    final Map<String, Double> byCategory = transactions.stream()
        .filter(t -> t.getAmount() > 0)
        .collect(Collectors.groupingBy(
            Transaction::getCategory,
            Collectors.summingDouble(Transaction::getAmount)
        ));
    return Map.of(
        "userId", userId,
        "username", user.getUsername(),
        "totalBudget", user.getBudget(),
        "totalSpent", totalSpent,
        "remaining", remaining,
        "categories", byCategory,
        "isOverBudget", remaining < 0,
        "warnings", warningsText,
        "hasWarnings", !warningsText.isEmpty()
    );
  }

  /**
   * Updates the user's budget with a new value. The budget must be non-negative.
   *
   * @param userId The {@code UUID} of the user.
   * @param updates A {@code Map} containing a "budget" key with the new budget value.
   * @throws IllegalArgumentException if the user is not found, if the budget value
   *         is invalid or negative, or if the format is incorrect.
   */
  public void setBudgets(final UUID userId, final Map<String, Object> updates) {
    final Optional<User> userOpt = getUser(userId);
    if (!userOpt.isPresent()) {
      throw new IllegalArgumentException(USER_NOT_FOUND);
    }
    if (updates.containsKey("budget")) {
      final Object budget = updates.get("budget");
      final double newBudget;
      if (budget instanceof Number) {
        newBudget = ((Number) budget).doubleValue();
      } else if (budget instanceof String) {
        newBudget = Double.parseDouble((String) budget);
      } else {
        throw new IllegalArgumentException("Invalid budget format");
      }
      if (newBudget < 0) {
        throw new IllegalArgumentException("Budget cannot be negative");
      }
      final String sql = "UPDATE users SET budget = ? WHERE user_id = ?";
      jdbcTemplate.update(sql, newBudget, userId);
    }
  }

  /**
   * Retrieves transactions created within the last seven days for a given user,
   * ordered by most recent first.
   *
   * @param userId The {@code UUID} of the user.
   * @return A {@code List} of {@code Transaction} objects created in the past week.
   */
  public List<Transaction> weeklySummary(final UUID userId) {
    final LocalDate oneWeekAgo = LocalDate.now().minusDays(7);
    final String sql = "SELECT * FROM transactions WHERE user_id = ? AND"
        + " created_date >= ? ORDER BY created_time DESC";
    return jdbcTemplate.query(sql, txRowMapper, userId, oneWeekAgo);
  }

  /**
   * Calculates the total spending for a user over the past seven days.
   * Only positive transaction amounts are included in the total.
   *
   * @param userId The {@code UUID} of the user.
   * @return The total spending amount for the last 7 days, or 0.0 if no transactions
   *         exist or if an error occurs.
   */
  public double totalLast7Days(final UUID userId) {
    final LocalDate oneWeekAgo = LocalDate.now().minusDays(7);
    final String sql = "SELECT COALESCE(SUM(amount), 0) FROM transactions"
        + " WHERE user_id = ? AND created_date >= ? AND amount > 0";
    try {
      final Double result = jdbcTemplate.queryForObject(sql, Double.class, userId, oneWeekAgo);
      return result != null ? result : 0.0;
    } catch (Exception e) {
      return 0.0;
    }
  }

  /**
   * Checks whether a username already exists in the database. Optionally excludes
   * a specific user ID from the search, useful for update operations where a user
   * is keeping their own username.
   *
   * @param username The username to check for.
   * @param excludeUserId The user ID to exclude from the search, or {@code null}
   *                      to check against all users.
   * @return {@code true} if the username exists (excluding the specified user if provided);
   *         {@code false} otherwise.
   */
  public boolean isUsernameExists(final String username, final UUID excludeUserId) {
    if (excludeUserId == null) {
      // Check against all users
      final String sql = "SELECT COUNT(*) FROM users WHERE username = ?";
      final Integer count = jdbcTemplate.queryForObject(sql, Integer.class, username);
      return count != null && count > 0;
    } else {
      // Check against other users only
      final String sql = "SELECT COUNT(*) FROM users WHERE username = ? AND user_id != ?";
      final Integer count = jdbcTemplate.queryForObject(sql,
          Integer.class, username, excludeUserId);
      return count != null && count > 0;
    }
  }

  /**
   * Checks whether an email already exists in the database. Optionally excludes
   * a specific user ID from the search, useful for update operations where a user
   * is keeping their own email.
   *
   * @param email The email to check for.
   * @param excludeUserId The user ID to exclude from the search, or {@code null}
   *                      to check against all users.
   * @return {@code true} if the email exists (excluding the specified user if provided);
   *         {@code false} otherwise.
   */
  public boolean isEmailExists(final String email, final UUID excludeUserId) {
    if (excludeUserId == null) {
      // Check against all users
      final String sql = "SELECT COUNT(*) FROM users WHERE email = ?";
      final Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email);
      return count != null && count > 0;
    } else {
      // Check against other users only
      final String sql = "SELECT COUNT(*) FROM users WHERE email = ? AND user_id != ?";
      final Integer count = jdbcTemplate.queryForObject(sql, Integer.class, email, excludeUserId);
      return count != null && count > 0;
    }
  }
}
