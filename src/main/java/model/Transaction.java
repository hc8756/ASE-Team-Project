package model;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Objects;
import java.util.UUID;

/**
 * This class defines the Transaction model used in the application.
 * <p>
 *  Each transcation represents a financial event linked to a specific user.
 *  A positive amount denotes an expense while a negative amount represents
 *  income or a refund. The class supports both date-only (for summaries) and
 *  timestamped (for precise ordering).
 * </p>
 */
public class Transaction implements Comparable<Transaction> {
  private UUID transactionId;
  private UUID userId;
  private String description; 
  private double amount;
  private String category;
  private LocalDateTime timestamp;
  private LocalDate date;

  public Transaction() {
  }

  /**
   * Constructs a new {@code Transaction} with the given user, amount, category, and description.
   * <p>
   * The {@code transactionId}, {@code timestamp}, and {@code date} are re automatically
   * generated by the database.
   * </p>
   *
   * @param userId The unique identifier of the user who made the transaction.
   * @param amount The amount of the transaction (positive for expense, negative for income).
   * @param category The category of the transaction.
   * @param description A brief description of the transaction.
   */
  public Transaction(UUID userId, double amount, String category, String description) {
    this.userId = userId;
    this.amount = amount;
    this.category = category;
    setDescription(description);
  }

  public UUID getTransactionId() { 
    return transactionId; 
  }

  public void setTransactionId(UUID id) { 
    this.transactionId = id; 
  }

  public UUID getUserId() { 
    return userId; 
  }

  public void setUserId(UUID id) {
    this.userId = id; 
  }

  public String getDescription() {
    return description; 
  }

  public void setDescription(String description) {
    this.description = (description == null) ? "" : description.trim();
  }

  public double getAmount() { 
    return amount; 
  }

  public void setAmount(double amount) { 
    this.amount = amount; 
  }

  public LocalDateTime getTimestamp() { 
    return timestamp; 
  }

  /**
   * Sets the exact timestamp for the transaction.
   * <p>
   * If a timestamp is provided, the corresponding date field is updated to match.
   * </p>
   *
   * @param timestamp The {@code LocalDateTime} value representing when the transaction occurred.
   */
  public void setTimestamp(LocalDateTime timestamp) {
    this.timestamp = (timestamp != null) ? timestamp : null;
    // Keep date in sync if possible
    if (this.timestamp != null) {
      this.date = this.timestamp.toLocalDate();
    }
  }

  public LocalDate getDate() { 
    return date; 
  }

  /**
   * Sets the calendar date for the transaction.
   * <p>
   * If a date is provided but no timestamp exists, the timestamp is automatically set
   * to the start of that day for consistency.
   * </p>
   *
   * @param date The {@code LocalDate} value representing the transaction date.
   */
  public void setDate(LocalDate date) {
    this.date = (date != null) ? date : null;
    // If we have a date but no timestamp, set timestamp to start of that day
    if (this.date != null && this.timestamp == null) {
      this.timestamp = this.date.atStartOfDay();
    }
  }

  public String getCategory() { 
    return category; 
  }

  public void setCategory(String category) { 
    this.category = category; 
  }

  /**
   * Returns the preferred ordering instant for this transaction.
   * <p>
   * If a timestamp exists, it is returned.
   * If only a date exists, it returns the start-of-day of that date.
   * If neither exists, {@code null} is returned.
   * </p>
   *
   * @return the preferred {@code LocalDateTime} instant for ordering,
   *     or {@code null} if unavailable.
   */
  public LocalDateTime effectiveInstant() {
    if (timestamp != null) {
      return timestamp;
    }
    if (date != null) {
      return date.atStartOfDay();
    }
    return null;
  }

  @Override
  public int compareTo(Transaction other) {
    if (other == null) {
      return 1;
    }
    LocalDateTime a = this.effectiveInstant();
    LocalDateTime b = other.effectiveInstant();
    
    if (a == null && b == null) {
      UUID ai = this.transactionId;
      UUID bi = other.transactionId;
      if (ai == null && bi == null) {
        return 0;
      }
      if (ai == null) {
        return -1;
      }
      if (bi == null) {
        return 1;
      }
      return ai.compareTo(bi);
    }
    
    if (a == null) {
      return -1;
    }
    if (b == null) {
      return 1;
    }
    
    int cmp = a.compareTo(b);
    if (cmp != 0) {
      return cmp;
    }
    
    UUID ai = this.transactionId;
    UUID bi = other.transactionId;
    if (ai == null && bi == null) {
      return 0;
    }
    if (ai == null) {
      return -1;
    }
    if (bi == null) {
      return 1;
    }
    return ai.compareTo(bi);
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (!(o instanceof Transaction)) {
      return false;
    }
    Transaction transaction = (Transaction) o;
    return Objects.equals(transactionId, transaction.transactionId);
  }

  @Override
  public int hashCode() { 
    return Objects.hash(transactionId); 
  }

  @Override
  public String toString() {
    return "Transaction{"
            + "id=" + transactionId
            + ", description='" + description + '\''
            + ", amount=" + amount
            + ", timestamp=" + timestamp
            + ", date=" + date
            + ", category='" + category + '\''
            + '}';
  }
}
